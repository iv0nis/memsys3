# Architecture Decision Records - memsys3
# Decisiones arquitectónicas del proyecto memsys3

adrs:
  - id: "006"
    titulo: "Sistema de rutas unificado memsys3/"
    data: "2025-10-29"
    estado: aceptado
    area: arquitectura

    context: |
      Durante el desarrollo inicial se creó confusión sobre las rutas en el sistema.
      Los prompts referencian archivos usando rutas relativas, pero cuando memsys3
      se despliega en diferentes proyectos, esas rutas deben ser consistentes.

      Inicialmente había inconsistencias:
      - Algunos prompts usaban `memory/`, otros `@memory/`
      - No estaba claro si las rutas eran del template o del deployment
      - Los READMEs mezclaban niveles (template vs sistema desplegado)

    decision: |
      TODAS las rutas en memsys3_templates/ deben usar el prefijo `memsys3/`:

      - `memsys3/memory/context.yaml`
      - `memsys3/agents/main-agent.yaml`
      - `memsys3/prompts/compile-context.md`
      - etc.

      Razón: Durante deployment, memsys3_templates/ se copia a la raíz del proyecto
      como `memsys3/`, por lo tanto todas las rutas internas funcionan correctamente.

      Además:
      - compile-context.md debe referenciar explícitamente `memsys3/agents/context-agent.yaml`
      - main-agent.yaml incluye restricción de NO proponer compile-context.md
      - READMEs separados por meta-nivel (repositorio vs sistema desplegado)

    alternatives:
      - nom: "Rutas relativas sin prefijo"
        pros:
          - Más cortas
          - Simples
        contras:
          - Ambigüedad sobre qué carpeta
          - Conflictos en proyectosconcarpeta 'memory/'
          - Difícil saber qué es de memsys3
        por_que_descartada: "No escalable, genera confusión"

      - nom: "Rutas absolutas desde raíz"
        pros:
          - Sin ambigüedad
        contras:
          - Dependiente de estructura del proyecto
          - No portable
        por_que_descartada: "No es portable entre proyectos"

    consequencies:
      positives:
        - "Claridad todal: siempre se sabe que es de memsys3"
        - "Portabilidad: funciona en cualquier proyecto"
        - "Actualizable: fácil saber qué archivos actualizar"
        - "Sin conflictosconcarpetas del proyecto"
      negatives:
        - "Rutas más largas en prompts"
        - "Requiere disciplina al crear nuevos prompts"
      impacto: "Cómo se estructuran y referencian todos los archivos del sistema"

  - id: "007"
    titulo: "Separación de meta-niveles en READMEs"
    data: "2025-10-29"
    estado: aceptado
    area: documentación

    context: |
      Inicialmente había un solo README que mezclaba:
      - Explicación de qué es memsys3 (para quien lo descubre)
      - Instrucciones de uso del sistema (para quien lo usa)
      - Información de templates y deployment
      - Dog-fooding del propio memsys3

      Esto generaba confusión porque no estaba claro el "nivel" de cada información.

    decision: |
      Crear READMEs separados por meta-nivel:

      1. README.md (raíz repositorio):
         - Meta-nivel: REPOSITORIO PÚBLICO
         - Audiencia: Quien descubre memsys3 en GitHub
         - Contenido: Qué es, cómo instalarlo, estructura del repo
         - Incluye: Explicación de dog-fooding (memsys3_templates/ vs memsys3/)

      2. memsys3_templates/README.md:
         - Meta-nivel: SISTEMA DESPLEGADO
         - Audiencia: Agents y developers DENTRO de un proyecto
         - Contenido: Cómo usar el sistema YA desplegado
         - NO menciona: Templates, deployment, ni meta-información
         - Escrito como si ya estuviera en producción

      3. docs/DEVELOPMENT.md:
         - Meta-nivel: DESARROLLO DE MEMSYS3
         - Audiencia: Contribuidores/desarrolladores de memsys3
         - Contenido: Workflow de desarrollo, sistema de rutas, checklist

      4. docs/UPDATE.md:
         - Meta-nivel: ACTUALIZACIÓN
         - Audiencia: Quien ya tiene memsys3 y quiere actualizar
         - Contenido: Qué archivos actualizar, qué preservar

    alternatives:
      - nom: "Un solo README para todo"
        pros:
          - Simple
          - Todo en un lugar
        contras:
          - Confusión de niveles
          - No está claro quién es la audiencia
          - Mezcla información de template vs deployment
        por_que_descartada: "Demasiada ambigüedad, difícil de mantener"

    consequencies:
      positives:
        - "Claridad todal de meta-niveles"
        - "Cada README tiene audiencia específica"
        - "Agents leen README agnóstico sin confusión"
        - "Developers tienen guía clara de contribución"
      negatives:
        - "Más archivos que mantener"
        - "Requiere disciplina para actualizar todos"
      impacto: "Cómo se estructura toda la documentación del proyecto"

  - id: "008"
    titulo: "Main-Agent NO debe proponer compile-context"
    data: "2025-10-29"
    estado: aceptado
    area: workflow

    context: |
      El Main-Agent trabaya durante sesiones acumulando tokens. compile-context.md
      requiere leer TODOS los archivos de memory/full/ (puede ser >50K tokens).

      Si el Main-Agent propone ejecutar compile-context, acumula:
      - Tokens de la sesión actual
      - Tokens de leer todo memory/full/
      - Tokens de generar context.yaml

      Esto es ineficiente y puede superar límites de contexto.

    decision: |
      Main-Agent tiene restricción explícita en agents/main-agent.yaml:
      - NO proponer ejecutar @memsys3/prompts/compile-context.md
      - Solo sugerir endSession al finalizar sesión
      - El user decide cuándo compilar (en nueva instancia limpia)

      compile-context.md debe ejecutarse en una NUEVA INSTANCIA sin tokens acumulados.

    alternatives:
      - nom: "Main-Agent ejecuta compile-context"
        pros:
          - Automático
          - Conveniente
        contras:
          - Acumula demasiados tokens
          - Ineficiente
          - Puede superar límites
        por_que_descartada: "Consume demasiados tokens innecesariamente"

      - nom: "Compilación automática en cada endSession"
        pros:
          - Context siempre actualizado
        contras:
          - Cada endSession sería muy pesado
          - No siempre es necesario recompilar
        por_que_descartada: "Overhead innecesario"

    consequencies:
      positives:
        - "Eficiencia de tokens optimizada"
        - "Main-Agent se enfoca en desarrollo"
        - "Context Agent trabayaconinstancia limpia"
        - "User controla cuándo compilar"
      negatives:
        - "Requiere paso manual extra de compilación"
        - "Context puede quedar desactualizado entre compilaciones"
      impacto: "Cómo se gestiona el workflow de compilación de contexto"

  - id: "001"
    titulo: "Criterio inteligente del Context Agent vs límites arbitrarios"
    data: "2025-10-28"
    estado: aceptado
    area: arquitectura

    context: |
      Los sistemas anteriores usaban límites rígidos (máx 7 ADRs, máx 15 líneas por sesión)
      que no se adaptaban a la realidad del proyecto. Proyectos pequeños perdían contexto,
      proyectos grandes no podían expresarse adecuadamente.

    decision: |
      El Context Agent usa criterio inteligente basándose en la pregunta:
      "¿Qué debe saber CUALQUIER agent descontextualizado para trabajar aquí?"

      Límite ÚNICO: máximo 2000 líneas en context.yaml final.
      NO hay límites arbitrarios para ADRs, sessions, gotchas, etc.

    alternatives:
      - nom: "Mantener límites arbitrarios"
        pros:
          - Predecible
          - Fácil de implementar
        contras:
          - No se adapta a realidad del proyecto
          - Pierde información crítica o incluye información irrelevante
        por_que_descartada: "Demasiado rígido, no escala con complejidad del proyecto"

      - nom: "Sin límite (contexto ilimitado)"
        pros:
          - Todo el contexto disponible
        contras:
          - Consume demasiados tokens
          - Supera límites de Read tool (2000 líneas)
        por_que_descartada: "No sostenible, problemas técnicos con Read"

    consequencies:
      positives:
        - "Contexto adaptativo según necesidades del proyecto"
        - "CA decideconvisión panorámica completa"
        - "Proyectos pequeños mantienen todo, proyectos grandes filtran inteligentemente"
        - "Más flexible y escalable"
      negatives:
        - "Menos predecible (depende criterio CA)"
        - "Puede variar entre compilaciones"
      impacto: "Cómo se compila todo el contexto del sistema"

  - id: "002"
    titulo: "Rotación automática de sessions/ADRs (flexible 1800-2000 líneas)"
    data: "2025-10-28"
    estado: aceptado
    area: escalabilidad
    ultima_actualizacion: "2025-12-03"

    context: |
      Read tool tiene límite de 2000 líneas. Si sessions.yaml o adr.yaml crecen
      demasiado, los agents no pueden leerlos.

      UPDATE 2025-12-03: Sistema de rotación mejorado con umbral flexible que aprovecha
      espacio disponible (1800-2000) y evita duplicación de sesión actual.

    decision: |
      Sistema de rotación flexible con dos escenarios:

      **Escenario A: 1800 < líneas < 2000** (Rotación LITE post-documentación)
      1. Documentar sesión normalmente en sessions.yaml
      2. DESPUÉS de documentar, si supera 1800 líneas:
         - Copiar sessions.yaml → sessions_N.yaml (incluye sesión actual)
         - Verificar copia (debe tener sesión actual)
         - Crear nuevo sessions.yaml VACÍO (solo header YAML)
      3. Resultado: Sesión actual SOLO en sessions_N.yaml (no duplicación)

      **Escenario B: líneas > 2000** (Rotación PRE-documentación)
      1. ANTES de documentar, rotar:
         - Copiar sessions.yaml → sessions_N.yaml (sin sesión actual)
         - Verificar copia
         - Crear nuevo sessions.yaml vacío
      2. Documentar sesión actual en sessions.yaml NUEVO (desde cero)
      3. Resultado: Sesión actual SOLO en sessions.yaml nuevo

      Context Agent lee TODOS los archivos rotados hasta detectar >150K tokens.

    alternatives:
      - nom: "Límite fijo de sessions/ADRs"
        pros:
          - Simple
        contras:
          - Pierde histórico
        por_que_descartada: "No queremos perder datos nunca"

      - nom: "Base de datos"
        pros:
          - Sin límites
        contras:
          - Complejidad adicional
          - Dependencia externa
        por_que_descartada: "YAML files son suficientes y simples"

    consequencies:
      positives:
        - "Sistema escala infinitamente"
        - "No se pierden datos nunca"
        - "Automático, sin intervención manual"
        - "Preserva histórico completo"
        - "Rotación flexible (1800-2000): aprovecha espacio disponible"
        - "Evita duplicación: sesión actual solo en un archivo"
        - "Solo rota cuando REALMENTE necesario (>2000)"
      negatives:
        - "Múltiples archivos (sessions_1, sessions_2, etc.)"
        - "CA debe leer múltiples archivos"
        - "Dos escenarios posibles (complejidad decisión)"
      impacto: "Cómo se gestiona el crecimiento de datos históricos"

    notes: |
      UPDATE 2025-12-03: Sistema mejorado tras primera rotación real (sessions.yaml 1849 líneas).
      Rotación flexible más eficiente: no rota rígidamente en 1800, aprovecha espacio hasta 2000.
      Evita duplicación documentando dónde queda sesión actual según escenario.

  - id: "003"
    titulo: "Plan de Contingenciaconarchivado inteligente (>150K tokens)"
    data: "2025-10-28"
    estado: aceptado
    area: escalabilidad

    context: |
      Inclusoconrotación, proyectos muy grandes pueden acumular demasiados datos.
      Si full/ (con todos los archivos rotados) supera 150K tokens, el CA no puede
      procesarlo eficientemente.

    decision: |
      Cuando todal de full/ supera 150K tokens:
      1. CA identifica ADRs/sessions irrelevantes con criterio inteligente
      2. Los mueve a memory/history/ (que NO se lee)
      3. Reduce a ~120K tokens
      4. Continúa compilación normal

      Datos en history/ están preservados, recuperables si es necesario.

    alternatives:
      - nom: "Borrar datos antiguos"
        pros:
          - Limpieza automática
        contras:
          - Pierde información irreversiblemente
        por_que_descartada: "NEVER delete data"

      - nom: "Comprimir archivos"
        pros:
          - Reduce tamaño
        contras:
          - CA no puede leer comprimido
        por_que_descartada: "No resuelve problema de tokens"

    consequencies:
      positives:
        - "Ahorro real de tokens (history/ NO se lee)"
        - "Datos preservados, no perdidos"
        - "Sistema escala ilimitadamente"
        - "Reversible (puedes recuperar de history/)"
      negatives:
        - "Datos archivados no visibles para CA"
        - "Depende criterio CA para archivar"
      impacto: "Cómo se gestionan proyectosconmucho histórico"

  - id: "004"
    titulo: "YAML para todo (incluyendo sessions)"
    data: "2025-10-28"
    estado: aceptado
    area: format

    context: |
      Sessions originalmentee eran .md (Markdown). Templates y ADRs ya eran YAML.
      Inconsistencia de formatos dificultaba parsing y ahorro de tokens.

    decision: |
      Todo el sistema usa YAML:
      - sessions.yaml (antes sessions.md)
      - adr.yaml
      - project-status.yaml
      - context.yaml
      - Todos los templates .yaml

    alternatives:
      - nom: "Markdown para sessions"
        pros:
          - Más legible para humans
        contras:
          - Inconsistentconresto
          - Más tokens (~30% más)
          - Difícil parsear para LLMs
        por_que_descartada: "Queríamos consistència y eficiencia"

      - nom: "JSON"
        pros:
          - Estándar web
        contras:
          - Menos legible
          - No soporta multiline strings fácilmente
        por_que_descartada: "YAML mejor para documentación"

    consequencies:
      positives:
        - "Consistencia todal del sistema"
        - "~30% ahorro tokens vs Markdown"
        - "Mejor para LLMs (estructura clara)"
        - "Fácil parsearconjs-yaml"
      negatives:
        - "Menos familiar para algunos devs"
        - "Requiere indentació estricta"
      impacto: "Formato de toda la documentació del sistema"

  - id: "005"
    titulo: "deploy.md como prompt (no script shell)"
    data: "2025-10-28"
    estado: aceptado
    area: usabilidad

    context: |
      Necesitábamos manera de desplegar memsys3 en nuevos proyectos.
      Opciones: script shell automático vs prompt para Main-Agent.

    decision: |
      Crear prompts/deploy.md que el Main-Agent ejecuta.
      El agent hace briefingconuser para personalizar el deployment:
      - Pregunta sobre proyecto, stack, comportamiento
      - Copia templates
      - Crea archivos específicos basándose en respuestas

      Más flexible que script automático.

    alternatives:
      - nom: "Script shell (setup.sh)"
        pros:
          - Automático
          - Rápido
        contras:
          - Menos flexible
          - No puede hacer briefingconuser
          - Requeriría CLI interactivo complex
        por_que_descartada: "Promptconagent es más inteligente y flexible"

      - nom: "Manual (README instructions)"
        pros:
          - Simple
        contras:
          - Propensos a errores humanos
          - Lento
        por_que_descartada: "Queríamos automatización"

    consequencies:
      positives:
        - "Deployment guiado e inteligente"
        - "Personalización según necesidades"
        - "Agent puede adaptarse a respuestas"
        - "Consistentconfilosofía de prompts"
      negatives:
        - "Requiere AI agent paraejecutar"
        - "No funciona sense agent"
      impacto: "Com los usuarios despliegan memsys3 en los sus proyectos"

  - id: "009"
    titulo: "Templates como documentació activa permanent + gotchas en sessions"
    data: "2025-10-31"
    estado: aceptado
    area: arquitectura

    context: |
      Durante la validación del deployment surgió confusión sobre tres aspectos:

      1. **Templates dentro de templates**: memsys3_templates/ es una carpeta-template completa,
         pero dentro tiene memory/templates/. Esto genera la pregunta: ¿qué es template de qué?

      2. **Uso de templates/**: Inicialmente se pensó en borrar memory/templates/ después
         del deployment, pero al revisar el contenido se descubrió que contiene:
         - Estructura exacta de ADRs, sessions, project-status
         - Instrucciones de uso (orden cronológico, límites, etc.)
         - Ejemplos de buena vs mala documentación
         - Especificaciones que endSession.md no detalla

      3. **Ubicación de gotchas**: project-status-template.yaml incluye sección gotchas_i_issues,
         pero los gotchas surgen DURANTE sesiones de trabajo, no son características estáticas
         del proyecto.

    decision: |
      **1. Concepto de memsys3_templates/ (ms3t):**
      - ms3t/ = Estructura EXACTA del producto final
      - Todos los archivos se copian durante deployment (incluido memory/templates/)
      - memory/templates/ NO se borra después del deployment

      **2. memory/templates/ = Guías permanentes:**
      - Main-Agent consulta templates/ durante endSession.md
      - "¿Cómo estructuro esta sesión?" → sessions-template.yaml
      - "¿Qué campos tiene un ADR?" → adr-template.yaml
      - "¿Qué puedo actualizar en project-status?" → project-status-template.yaml
      - Templates son documentación ACTIVA, no solo guías de deployment

      **3. Gotchas documentados en sessions.yaml:**
      - Main-Agent documenta gotchas en cada sesión donde aparecen
      - Estructura en sessions.yaml:
        ```yaml
        sessions:
          - id: "2025-10-31"
            gotchas:
              - tipus: "warning|gotcha|issue"
                problema: "[DESCRIPCIÓ]"
                solucio: "[COM RESOLDRE]"
                criticidad: "alta|media|baja"
        ```
      - Context-Agent extrae gotchas de TODAS las sesiones
      - CA usa criterio inteligente para seleccionar top 5 más críticos
      - Criterios: criticidad + recencia + impacto
      - project-status.yaml NO contiene gotchas (solo info general del proyecto)

      **4. Templatesconcomentarios explicativos:**
      - Camposcon[PLACEHOLDER] y comentarios inline
      - Ejemplos de buenas prácticas
      - deploy.md usa templates como guía para hacer briefing

      **5. Workflow de deployment actualizado:**
      ```bash
      # Usuario dice:
      "Clona https://github.com/iv0nis/memsys3 como memsys3_temp
       y ejecuta memsys3_temp/memsys3/prompts/deploy.md"

      # Flujo:
      1. git clone https://github.com/iv0nis/memsys3 memsys3_temp
      2. cp -r memsys3_temp/memsys3/* ./memsys3/
      3. Briefing usando templates/ como guía
      4. Rellenar campos vacíos en project-status.yaml, main-agent.yaml
      5. rm -rf memsys3_temp/

      # Resultado: memsys3/conmemory/templates/ incluido (permanente)
      ```

    alternatives:
      - nom: "Borrar templates/ després del deployment"
        pros:
          - Menos archivos en el proyecto desplegado (~15KB menos)
          - Más limpio
        contras:
          - Main-Agent pierde referencia de cómo documentar
          - endSession.md no tiene guía de estructura
          - Ejemplos de buenas prácticas se pierden
        por_que_descartada: "Templates son críticos para Main-Agent durante todo el proyecto"

      - nom: "Gotchas en project-status.yaml"
        pros:
          - Centralizado en un solo lugar
          - Fácil de encontrar
        contras:
          - Descontextualizados (no se sabe cuándo aparecieron)
          - project-status más inflado
          - No tiene sentido conceptual (gotchas surgen durante sesiones)
        por_que_descartada: "Gotchas son eventos de sesiones, no características estáticas"

      - nom: "Crear archivo gotchas.yaml separat"
        pros:
          - Dedicado solo a gotchas
        contras:
          - Un archivo más
          - Descontextualizados igualmente
          - CA debería leer un archivo extra
        por_que_descartada: "Sessions ya documentan contexto temporal de los gotchas"

    consequencies:
      positives:
        - "Deployment más simple: copiar todo, no borrar templates/"
        - "Main-Agent siempre tiene referencia de cómo documentar correctamente"
        - "Gotchas contextualizados (cuándo aparecieron, en qué sesión)"
        - "CA tiene flexibilidad para priorizar gotchas según criterio"
        - "project-status.yaml más limpio (solo info general)"
        - "Templates enriquecidosconcomentarios guían briefing de deployment"
        - "~15KB extra en proyecto (4 templates, aceptable)"
      negatives:
        - "memory/templates/ se mantiene pero no se borra (puede parecer residual)"
        - "Gotchas dispersos entre sesiones (hay que leer todas para compilar)"
        - "Templates/ como nombre puede generar confusión (son guías, no templates)"
      impacto: "Cómo se despliega memsys3, cómo Main-Agent documenta sesiones, dónde se guardan gotchas"

    notes: |
      Esta ADR resuelve confusiones críticas descubiertas durante validación de deployment.

      Consideración futura: Quizás renombrar memory/templates/ a memory/guides/ para más
      claridad conceptual, pero se mantiene templates/ para no romper nada ahora.

  - id: "012"
    titulo: "README como lectura directa vs duplicado en context.yaml"
    data: "2025-12-03"
    estado: aceptado
    area: arquitectura

    context: |
      Durante el deployment en otros proyectos se detectó que README.md cambia frecuentemente
      (versiones, features nuevas, URLs, stack tecnológico), pero context.yaml solo se actualiza
      cuando se ejecuta compile-context.md.

      Problema identificado:
      - README sintetizado en context.yaml quedaba desactualizado
      - Requería re-ejecutar compile-context por cambios triviales en README
      - Context Agent hacía "Análisis profundo README" (PASO 7) comparando README vs realidad,
        pero si README ES la realidad, el análisis no tiene sentido
      - Duplicación innecesaria: README existe como archivo independiente

      Observación arquitectónica:
      - README.md = "Quién soy ahora" (identidad actual del proyecto)
      - context.yaml = "Qué he aprendido" (memoria histórica: sessions, ADRs, gotchas)

      Estos son dos conceptos diferentes que no deberían mezclarse.

    decision: |
      README.md se lee DIRECTAMENTE en newSession.md, NO se incluye en context.yaml.

      Cambios implementados:

      1. newSession.md:
         - Agregada instrucción explícita: "Lee README.md del proyecto"
         - Orden de carga: README.md → project-status.yaml → context.yaml
         - README proporciona identidad actual, context proporciona memoria histórica

      2. compile-context.md:
         - ELIMINADO "Paso Previo: Verificar README.md" (creación automática)
         - ELIMINADO "PASO 7: Análisis profundo README" (comparación vs realidad)
         - ELIMINADO de lista de archivos a leer
         - Context Agent ya NO incluye README en el contexto compilado

      3. context-template.yaml:
         - ELIMINADA sección `readme_proyecto:`
         - Agregado comentario: "README.md se lee directamente en newSession.md"

      Filosofía: Separation of Concerns
      - README = Identidad actual (fuente de verdad, siempre actualizada)
      - context = Memoria histórica (síntesis de aprendizajes)

    alternatives:
      - nom: "Status quo (mantener README en context.yaml)"
        pros:
          - context.yaml sigue siendo archivo único con todo
          - No requiere cambios
        contras:
          - Riesgo permanente de desincronización
          - Re-compilaciones por cambios triviales
          - Mantenimiento innecesario
          - Análisis README paradójico (comparar contra sí mismo)
        por_que_descartada: "Desincronización inevitable, mantenimiento costoso"

      - nom: "README solo si no existe en proyecto"
        pros:
          - Útil para proyectos sin README
          - Permite crear README automático desde project-status
        contras:
          - Complejidad condicional
          - Sigue teniendo problema de desincronización si README existe
        por_que_descartada: "No resuelve el problema principal (desincronización)"

      - nom: "README en context + análisis profundo mejorado"
        pros:
          - Detecta discrepancias automáticamente
          - CA puede actualizar README automáticamente
        contras:
          - Añade complejidad enorme (PASO 7 era ~250 líneas)
          - Sigue duplicando información
          - README debería SER la realidad, no compararse contra ella
        por_que_descartada: "Arquitectónicamente incorrecto: README ES la fuente de verdad"

    consequencies:
      positives:
        - "Imposible desincronización: README siempre es la versión actual"
        - "No duplicación: una sola fuente de verdad"
        - "Menos mantenimiento: no re-compilar por cambios en README"
        - "Overhead trivial: 1 Read adicional (~200-400 líneas) es irrelevante"
        - "Coherencia conceptual: README = identidad, context = memoria"
        - "compile-context más enfocado: solo memoria histórica"
        - "~95 líneas menos en context.yaml (~1.4K tokens ahorrados)"
      negatives:
        - "context.yaml ya NO es archivo único con todo (pequeña desviación conceptual)"
        - "Un Read adicional en newSession (+1 tool call)"
      impacto: "newSession.md, compile-context.md, context-template.yaml, context.yaml de todos los proyectos"

    notes: |
      Esta ADR resuelve IMPROVEMENT-004 del backlog.

      Conflicto resuelto: IMPROVEMENT-001 (2025-11-03) proponía incluir README en context,
      pero esta decisión (IMPROVEMENT-004, 2025-12-03) es arquitectónicamente más madura:
      separar "identidad actual" vs "memoria histórica".

      IMPROVEMENT-001 puede reconsiderarse para OTROS documentos críticos (DEVELOPMENT.md, etc.)
      pero README específicamente debe leerse directamente.

      Compatibilidad: Proyectos con context.yaml antiguo (con README incluido) seguirán funcionando,
      pero en próxima compilación README se eliminará del context automáticamente.
