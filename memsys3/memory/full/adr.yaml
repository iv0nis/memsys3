# Architecture Decision Records - memsys3
# Decisiones arquitectónicas del proyecto memsys3

adrs:
  - id: "006"
    titulo: "Sistema de rutas unificado memsys3/"
    data: "2025-10-29"
    estado: aceptado
    area: arquitectura

    context: |
      Durante el desarrollo inicial se creó confusión sobre las rutas en el sistema.
      Los prompts referencian archivos usando rutas relativas, pero cuando memsys3
      se despliega en diferentes proyectos, esas rutas deben ser consistentes.

      Inicialmente había inconsistencias:
      - Algunos prompts usaban `memory/`, otros `@memory/`
      - No estaba claro si las rutas eran del template o del deployment
      - Los READMEs mezclaban niveles (template vs sistema desplegado)

    decision: |
      TODAS las rutas en memsys3_templates/ deben usar el prefijo `memsys3/`:

      - `memsys3/memory/context.yaml`
      - `memsys3/agents/main-agent.yaml`
      - `memsys3/prompts/compile-context.md`
      - etc.

      Razón: Durante deployment, memsys3_templates/ se copia a la raíz del proyecto
      como `memsys3/`, por lo tanto todas las rutas internas funcionan correctamente.

      Además:
      - compile-context.md debe referenciar explícitamente `memsys3/agents/context-agent.yaml`
      - main-agent.yaml incluye restricción de NO proponer compile-context.md
      - READMEs separados por meta-nivel (repositorio vs sistema desplegado)

    alternatives:
      - nom: "Rutas relativas sin prefijo"
        pros:
          - Más cortas
          - Simples
        contras:
          - Ambigüedad sobre qué carpeta
          - Conflictos en proyectosconcarpeta 'memory/'
          - Difícil saber qué es de memsys3
        por_que_descartada: "No escalable, genera confusión"

      - nom: "Rutas absolutas desde raíz"
        pros:
          - Sin ambigüedad
        contras:
          - Dependiente de estructura del proyecto
          - No portable
        por_que_descartada: "No es portable entre proyectos"

    consequencies:
      positives:
        - "Claridad todal: siempre se sabe que es de memsys3"
        - "Portabilidad: funciona en cualquier proyecto"
        - "Actualizable: fácil saber qué archivos actualizar"
        - "Sin conflictosconcarpetas del proyecto"
      negatives:
        - "Rutas más largas en prompts"
        - "Requiere disciplina al crear nuevos prompts"
      impacto: "Cómo se estructuran y referencian todos los archivos del sistema"

  - id: "007"
    titulo: "Separación de meta-niveles en READMEs"
    data: "2025-10-29"
    estado: aceptado
    area: documentación

    context: |
      Inicialmente había un solo README que mezclaba:
      - Explicación de qué es memsys3 (para quien lo descubre)
      - Instrucciones de uso del sistema (para quien lo usa)
      - Información de templates y deployment
      - Dog-fooding del propio memsys3

      Esto generaba confusión porque no estaba claro el "nivel" de cada información.

    decision: |
      Crear READMEs separados por meta-nivel:

      1. README.md (raíz repositorio):
         - Meta-nivel: REPOSITORIO PÚBLICO
         - Audiencia: Quien descubre memsys3 en GitHub
         - Contenido: Qué es, cómo instalarlo, estructura del repo
         - Incluye: Explicación de dog-fooding (memsys3_templates/ vs memsys3/)

      2. memsys3_templates/README.md:
         - Meta-nivel: SISTEMA DESPLEGADO
         - Audiencia: Agents y developers DENTRO de un proyecto
         - Contenido: Cómo usar el sistema YA desplegado
         - NO menciona: Templates, deployment, ni meta-información
         - Escrito como si ya estuviera en producción

      3. docs/DEVELOPMENT.md:
         - Meta-nivel: DESARROLLO DE MEMSYS3
         - Audiencia: Contribuidores/desarrolladores de memsys3
         - Contenido: Workflow de desarrollo, sistema de rutas, checklist

      4. docs/UPDATE.md:
         - Meta-nivel: ACTUALIZACIÓN
         - Audiencia: Quien ya tiene memsys3 y quiere actualizar
         - Contenido: Qué archivos actualizar, qué preservar

    alternatives:
      - nom: "Un solo README para todo"
        pros:
          - Simple
          - Todo en un lugar
        contras:
          - Confusión de niveles
          - No está claro quién es la audiencia
          - Mezcla información de template vs deployment
        por_que_descartada: "Demasiada ambigüedad, difícil de mantener"

    consequencies:
      positives:
        - "Claridad todal de meta-niveles"
        - "Cada README tiene audiencia específica"
        - "Agents leen README agnóstico sin confusión"
        - "Developers tienen guía clara de contribución"
      negatives:
        - "Más archivos que mantener"
        - "Requiere disciplina para actualizar todos"
      impacto: "Cómo se estructura toda la documentación del proyecto"

  - id: "008"
    titulo: "Main-Agent NO debe proponer compile-context"
    data: "2025-10-29"
    estado: aceptado
    area: workflow

    context: |
      El Main-Agent trabaya durante sesiones acumulando tokens. compile-context.md
      requiere leer TODOS los archivos de memory/full/ (puede ser >50K tokens).

      Si el Main-Agent propone ejecutar compile-context, acumula:
      - Tokens de la sesión actual
      - Tokens de leer todo memory/full/
      - Tokens de generar context.yaml

      Esto es ineficiente y puede superar límites de contexto.

    decision: |
      Main-Agent tiene restricción explícita en agents/main-agent.yaml:
      - NO proponer ejecutar @memsys3/prompts/compile-context.md
      - Solo sugerir endSession al finalizar sesión
      - El user decide cuándo compilar (en nueva instancia limpia)

      compile-context.md debe ejecutarse en una NUEVA INSTANCIA sin tokens acumulados.

    alternatives:
      - nom: "Main-Agent ejecuta compile-context"
        pros:
          - Automático
          - Conveniente
        contras:
          - Acumula demasiados tokens
          - Ineficiente
          - Puede superar límites
        por_que_descartada: "Consume demasiados tokens innecesariamente"

      - nom: "Compilación automática en cada endSession"
        pros:
          - Context siempre actualizado
        contras:
          - Cada endSession sería muy pesado
          - No siempre es necesario recompilar
        por_que_descartada: "Overhead innecesario"

    consequencies:
      positives:
        - "Eficiencia de tokens optimizada"
        - "Main-Agent se enfoca en desarrollo"
        - "Context Agent trabayaconinstancia limpia"
        - "User controla cuándo compilar"
      negatives:
        - "Requiere paso manual extra de compilación"
        - "Context puede quedar desactualizado entre compilaciones"
      impacto: "Cómo se gestiona el workflow de compilación de contexto"

  - id: "001"
    titulo: "Criterio inteligente del Context Agent vs límites arbitrarios"
    data: "2025-10-28"
    estado: aceptado
    area: arquitectura

    context: |
      Los sistemas anteriores usaban límites rígidos (máx 7 ADRs, máx 15 líneas por sesión)
      que no se adaptaban a la realidad del proyecto. Proyectos pequeños perdían contexto,
      proyectos grandes no podían expresarse adecuadamente.

    decision: |
      El Context Agent usa criterio inteligente basándose en la pregunta:
      "¿Qué debe saber CUALQUIER agent descontextualizado para trabajar aquí?"

      Límite ÚNICO: máximo 2000 líneas en context.yaml final.
      NO hay límites arbitrarios para ADRs, sessions, gotchas, etc.

    alternatives:
      - nom: "Mantener límites arbitrarios"
        pros:
          - Predecible
          - Fácil de implementar
        contras:
          - No se adapta a realidad del proyecto
          - Pierde información crítica o incluye información irrelevante
        por_que_descartada: "Demasiado rígido, no escala con complejidad del proyecto"

      - nom: "Sin límite (contexto ilimitado)"
        pros:
          - Todo el contexto disponible
        contras:
          - Consume demasiados tokens
          - Supera límites de Read tool (2000 líneas)
        por_que_descartada: "No sostenible, problemas técnicos con Read"

    consequencies:
      positives:
        - "Contexto adaptativo según necesidades del proyecto"
        - "CA decideconvisión panorámica completa"
        - "Proyectos pequeños mantienen todo, proyectos grandes filtran inteligentemente"
        - "Más flexible y escalable"
      negatives:
        - "Menos predecible (depende criterio CA)"
        - "Puede variar entre compilaciones"
      impacto: "Cómo se compila todo el contexto del sistema"

  - id: "002"
    titulo: "Rotación automática de sessions/ADRs (>1800 líneas)"
    data: "2025-10-28"
    estado: aceptado
    area: escalabilidad

    context: |
      Read tool tiene límite de 2000 líneas. Si sessions.yaml o adr.yaml crecen
      demasiado, los agents no pueden leerlos.

    decision: |
      Cuando sessions.yaml o adr.yaml superen 1800 líneas:
      - endSession.md detecta automáticamente
      - Hace rotación segura: copia → verifica → crea nuevo
      - sessions.yaml → sessions_N.yaml
      - adr.yaml → adr_N.yaml

      Context Agent lee TODOS los archivos rotados hasta detectar >150K tokens.

    alternatives:
      - nom: "Límite fijo de sessions/ADRs"
        pros:
          - Simple
        contras:
          - Pierde histórico
        por_que_descartada: "No queremos perder datos nunca"

      - nom: "Base de datos"
        pros:
          - Sin límites
        contras:
          - Complejidad adicional
          - Dependencia externa
        por_que_descartada: "YAML files son suficientes y simples"

    consequencies:
      positives:
        - "Sistema escala infinitamente"
        - "No se pierden datos nunca"
        - "Automático, sin intervención manual"
        - "Preserva histórico completo"
      negatives:
        - "Múltiples archivos (sessions_1, sessions_2, etc.)"
        - "CA debe leer múltiples archivos"
      impacto: "Cómo se gestiona el crecimiento de datos históricos"

  - id: "003"
    titulo: "Plan de Contingenciaconarchivado inteligente (>150K tokens)"
    data: "2025-10-28"
    estado: aceptado
    area: escalabilidad

    context: |
      Inclusoconrotación, proyectos muy grandes pueden acumular demasiados datos.
      Si full/ (con todos los archivos rotados) supera 150K tokens, el CA no puede
      procesarlo eficientemente.

    decision: |
      Cuando todal de full/ supera 150K tokens:
      1. CA identifica ADRs/sessions irrelevantes con criterio inteligente
      2. Los mueve a memory/history/ (que NO se lee)
      3. Reduce a ~120K tokens
      4. Continúa compilación normal

      Datos en history/ están preservados, recuperables si es necesario.

    alternatives:
      - nom: "Borrar datos antiguos"
        pros:
          - Limpieza automática
        contras:
          - Pierde información irreversiblemente
        por_que_descartada: "NEVER delete data"

      - nom: "Comprimir archivos"
        pros:
          - Reduce tamaño
        contras:
          - CA no puede leer comprimido
        por_que_descartada: "No resuelve problema de tokens"

    consequencies:
      positives:
        - "Ahorro real de tokens (history/ NO se lee)"
        - "Datos preservados, no perdidos"
        - "Sistema escala ilimitadamente"
        - "Reversible (puedes recuperar de history/)"
      negatives:
        - "Datos archivados no visibles para CA"
        - "Depende criterio CA para archivar"
      impacto: "Cómo se gestionan proyectosconmucho histórico"

  - id: "004"
    titulo: "YAML para todo (incluyendo sessions)"
    data: "2025-10-28"
    estado: aceptado
    area: format

    context: |
      Sessions originalmentee eran .md (Markdown). Templates y ADRs ya eran YAML.
      Inconsistencia de formatos dificultaba parsing y ahorro de tokens.

    decision: |
      Todo el sistema usa YAML:
      - sessions.yaml (antes sessions.md)
      - adr.yaml
      - project-status.yaml
      - context.yaml
      - Todos los templates .yaml

    alternatives:
      - nom: "Markdown para sessions"
        pros:
          - Más legible para humans
        contras:
          - Inconsistentconresto
          - Más tokens (~30% más)
          - Difícil parsear para LLMs
        por_que_descartada: "Queríamos consistència y eficiencia"

      - nom: "JSON"
        pros:
          - Estándar web
        contras:
          - Menos legible
          - No soporta multiline strings fácilmente
        por_que_descartada: "YAML mejor para documentación"

    consequencies:
      positives:
        - "Consistencia todal del sistema"
        - "~30% ahorro tokens vs Markdown"
        - "Mejor para LLMs (estructura clara)"
        - "Fácil parsearconjs-yaml"
      negatives:
        - "Menos familiar para algunos devs"
        - "Requiere indentació estricta"
      impacto: "Formato de toda la documentació del sistema"

  - id: "005"
    titulo: "deploy.md como prompt (no script shell)"
    data: "2025-10-28"
    estado: aceptado
    area: usabilidad

    context: |
      Necesitábamos manera de desplegar memsys3 en nuevos proyectos.
      Opciones: script shell automático vs prompt para Main-Agent.

    decision: |
      Crear prompts/deploy.md que el Main-Agent ejecuta.
      El agent hace briefingconuser para personalizar el deployment:
      - Pregunta sobre proyecto, stack, comportamiento
      - Copia templates
      - Crea archivos específicos basándose en respuestas

      Más flexible que script automático.

    alternatives:
      - nom: "Script shell (setup.sh)"
        pros:
          - Automático
          - Rápido
        contras:
          - Menos flexible
          - No puede hacer briefingconuser
          - Requeriría CLI interactivo complex
        por_que_descartada: "Promptconagent es más inteligente y flexible"

      - nom: "Manual (README instructions)"
        pros:
          - Simple
        contras:
          - Propensos a errores humanos
          - Lento
        por_que_descartada: "Queríamos automatización"

    consequencies:
      positives:
        - "Deployment guiado e inteligente"
        - "Personalización según necesidades"
        - "Agent puede adaptarse a respuestas"
        - "Consistentconfilosofía de prompts"
      negatives:
        - "Requiere AI agent paraejecutar"
        - "No funciona sense agent"
      impacto: "Com los usuarios despliegan memsys3 en los sus proyectos"

  - id: "009"
    titulo: "Templates como documentació activa permanent + gotchas en sessions"
    data: "2025-10-31"
    estado: aceptado
    area: arquitectura

    context: |
      Durante la validación del deployment surgió confusión sobre tres aspectos:

      1. **Templates dentro de templates**: memsys3_templates/ es una carpeta-template completa,
         pero dentro tiene memory/templates/. Esto genera la pregunta: ¿qué es template de qué?

      2. **Uso de templates/**: Inicialmente se pensó en borrar memory/templates/ después
         del deployment, pero al revisar el contenido se descubrió que contiene:
         - Estructura exacta de ADRs, sessions, project-status
         - Instrucciones de uso (orden cronológico, límites, etc.)
         - Ejemplos de buena vs mala documentación
         - Especificaciones que endSession.md no detalla

      3. **Ubicación de gotchas**: project-status-template.yaml incluye sección gotchas_i_issues,
         pero los gotchas surgen DURANTE sesiones de trabajo, no son características estáticas
         del proyecto.

    decision: |
      **1. Concepto de memsys3_templates/ (ms3t):**
      - ms3t/ = Estructura EXACTA del producto final
      - Todos los archivos se copian durante deployment (incluido memory/templates/)
      - memory/templates/ NO se borra después del deployment

      **2. memory/templates/ = Guías permanentes:**
      - Main-Agent consulta templates/ durante endSession.md
      - "¿Cómo estructuro esta sesión?" → sessions-template.yaml
      - "¿Qué campos tiene un ADR?" → adr-template.yaml
      - "¿Qué puedo actualizar en project-status?" → project-status-template.yaml
      - Templates son documentación ACTIVA, no solo guías de deployment

      **3. Gotchas documentados en sessions.yaml:**
      - Main-Agent documenta gotchas en cada sesión donde aparecen
      - Estructura en sessions.yaml:
        ```yaml
        sessions:
          - id: "2025-10-31"
            gotchas:
              - tipus: "warning|gotcha|issue"
                problema: "[DESCRIPCIÓ]"
                solucio: "[COM RESOLDRE]"
                criticidad: "alta|media|baja"
        ```
      - Context-Agent extrae gotchas de TODAS las sesiones
      - CA usa criterio inteligente para seleccionar top 5 más críticos
      - Criterios: criticidad + recencia + impacto
      - project-status.yaml NO contiene gotchas (solo info general del proyecto)

      **4. Templatesconcomentarios explicativos:**
      - Camposcon[PLACEHOLDER] y comentarios inline
      - Ejemplos de buenas prácticas
      - deploy.md usa templates como guía para hacer briefing

      **5. Workflow de deployment actualizado:**
      ```bash
      # Usuario dice:
      "Clona https://github.com/iv0nis/memsys3 como memsys3_temp
       y ejecuta memsys3_temp/memsys3/prompts/deploy.md"

      # Flujo:
      1. git clone https://github.com/iv0nis/memsys3 memsys3_temp
      2. cp -r memsys3_temp/memsys3/* ./memsys3/
      3. Briefing usando templates/ como guía
      4. Rellenar campos vacíos en project-status.yaml, main-agent.yaml
      5. rm -rf memsys3_temp/

      # Resultado: memsys3/conmemory/templates/ incluido (permanente)
      ```

    alternatives:
      - nom: "Borrar templates/ després del deployment"
        pros:
          - Menos archivos en el proyecto desplegado (~15KB menos)
          - Más limpio
        contras:
          - Main-Agent pierde referencia de cómo documentar
          - endSession.md no tiene guía de estructura
          - Ejemplos de buenas prácticas se pierden
        por_que_descartada: "Templates son críticos para Main-Agent durante todo el proyecto"

      - nom: "Gotchas en project-status.yaml"
        pros:
          - Centralizado en un solo lugar
          - Fácil de encontrar
        contras:
          - Descontextualizados (no se sabe cuándo aparecieron)
          - project-status más inflado
          - No tiene sentido conceptual (gotchas surgen durante sesiones)
        por_que_descartada: "Gotchas son eventos de sesiones, no características estáticas"

      - nom: "Crear archivo gotchas.yaml separat"
        pros:
          - Dedicado solo a gotchas
        contras:
          - Un archivo más
          - Descontextualizados igualmente
          - CA debería leer un archivo extra
        por_que_descartada: "Sessions ya documentan contexto temporal de los gotchas"

    consequencies:
      positives:
        - "Deployment más simple: copiar todo, no borrar templates/"
        - "Main-Agent siempre tiene referencia de cómo documentar correctamente"
        - "Gotchas contextualizados (cuándo aparecieron, en qué sesión)"
        - "CA tiene flexibilidad para priorizar gotchas según criterio"
        - "project-status.yaml más limpio (solo info general)"
        - "Templates enriquecidosconcomentarios guían briefing de deployment"
        - "~15KB extra en proyecto (4 templates, aceptable)"
      negatives:
        - "memory/templates/ se mantiene pero no se borra (puede parecer residual)"
        - "Gotchas dispersos entre sesiones (hay que leer todas para compilar)"
        - "Templates/ como nombre puede generar confusión (son guías, no templates)"
      impacto: "Cómo se despliega memsys3, cómo Main-Agent documenta sesiones, dónde se guardan gotchas"

    notes: |
      Esta ADR resuelve confusiones críticas descubiertas durante validación de deployment.

      Consideración futura: Quizás renombrar memory/templates/ a memory/guides/ para más
      claridad conceptual, pero se mantiene templates/ para no romper nada ahora.
