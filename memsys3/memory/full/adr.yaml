# Architecture Decision Records - memsys3
# Decisiones arquitectónicas del proyecto memsys3

adrs:
  - id: "006"
    titulo: "Sistema de rutas unificado memsys3/"
    data: "2025-10-29"
    estado: aceptado
    area: arquitectura

    context: |
      Durante el desarrollo inicial se creó confusión sobre las rutas en el sistema.
      Los prompts referencian archivos usando rutas relativas, pero cuando memsys3
      se despliega en diferentes proyectos, esas rutas deben ser consistentes.

      Inicialmente había inconsistencias:
      - Algunos prompts usaban `memory/`, otros `@memory/`
      - No estaba claro si las rutas eran del template o del deployment
      - Los READMEs mezclaban niveles (template vs sistema desplegado)

    decision: |
      TODAS las rutas en memsys3_templates/ deben usar el prefijo `memsys3/`:

      - `memsys3/memory/context.yaml`
      - `memsys3/agents/main-agent.yaml`
      - `memsys3/prompts/compile-context.md`
      - etc.

      Razón: Durante deployment, memsys3_templates/ se copia a la raíz del proyecto
      como `memsys3/`, por lo tanto todas las rutas internas funcionan correctamente.

      Además:
      - compile-context.md debe referenciar explícitamente `memsys3/agents/context-agent.yaml`
      - main-agent.yaml incluye restricción de NO proponer compile-context.md
      - READMEs separados por meta-nivel (repositorio vs sistema desplegado)

    alternatives:
      - nom: "Rutas relativas sin prefijo"
        pros:
          - Más cortas
          - Simples
        contras:
          - Ambigüedad sobre qué carpeta
          - Conflictos en proyectosconcarpeta 'memory/'
          - Difícil saber qué es de memsys3
        por_que_descartada: "No escalable, genera confusión"

      - nom: "Rutas absolutas desde raíz"
        pros:
          - Sin ambigüedad
        contras:
          - Dependiente de estructura del proyecto
          - No portable
        por_que_descartada: "No es portable entre proyectos"

    consequencies:
      positives:
        - "Claridad todal: siempre se sabe que es de memsys3"
        - "Portabilidad: funciona en cualquier proyecto"
        - "Actualizable: fácil saber qué archivos actualizar"
        - "Sin conflictosconcarpetas del proyecto"
      negatives:
        - "Rutas más largas en prompts"
        - "Requiere disciplina al crear nuevos prompts"
      impacto: "Cómo se estructuran y referencian todos los archivos del sistema"

  - id: "007"
    titulo: "Separación de meta-niveles en READMEs"
    data: "2025-10-29"
    estado: aceptado
    area: documentación

    context: |
      Inicialmente había un solo README que mezclaba:
      - Explicación de qué es memsys3 (para quien lo descubre)
      - Instrucciones de uso del sistema (para quien lo usa)
      - Información de templates y deployment
      - Dog-fooding del propio memsys3

      Esto generaba confusión porque no estaba claro el "nivel" de cada información.

    decision: |
      Crear READMEs separados por meta-nivel:

      1. README.md (raíz repositorio):
         - Meta-nivel: REPOSITORIO PÚBLICO
         - Audiencia: Quien descubre memsys3 en GitHub
         - Contenido: Qué es, cómo instalarlo, estructura del repo
         - Incluye: Explicación de dog-fooding (memsys3_templates/ vs memsys3/)

      2. memsys3_templates/README.md:
         - Meta-nivel: SISTEMA DESPLEGADO
         - Audiencia: Agents y developers DENTRO de un proyecto
         - Contenido: Cómo usar el sistema YA desplegado
         - NO menciona: Templates, deployment, ni meta-información
         - Escrito como si ya estuviera en producción

      3. docs/DEVELOPMENT.md:
         - Meta-nivel: DESARROLLO DE MEMSYS3
         - Audiencia: Contribuidores/desarrolladores de memsys3
         - Contenido: Workflow de desarrollo, sistema de rutas, checklist

      4. docs/UPDATE.md:
         - Meta-nivel: ACTUALIZACIÓN
         - Audiencia: Quien ya tiene memsys3 y quiere actualizar
         - Contenido: Qué archivos actualizar, qué preservar

    alternatives:
      - nom: "Un solo README para todo"
        pros:
          - Simple
          - Todo en un lugar
        contras:
          - Confusión de niveles
          - No está claro quién es la audiencia
          - Mezcla información de template vs deployment
        por_que_descartada: "Demasiada ambigüedad, difícil de mantener"

    consequencies:
      positives:
        - "Claridad todal de meta-niveles"
        - "Cada README tiene audiencia específica"
        - "Agents leen README agnóstico sin confusión"
        - "Developers tienen guía clara de contribución"
      negatives:
        - "Más archivos que mantener"
        - "Requiere disciplina para actualizar todos"
      impacto: "Cómo se estructura toda la documentación del proyecto"

  - id: "008"
    titulo: "Main-Agent NO debe proponer compile-context"
    data: "2025-10-29"
    estado: aceptado
    area: workflow

    context: |
      El Main-Agent trabaya durante sesiones acumulando tokens. compile-context.md
      requiere leer TODOS los archivos de memory/full/ (puede ser >50K tokens).

      Si el Main-Agent propone ejecutar compile-context, acumula:
      - Tokens de la sesión actual
      - Tokens de leer todo memory/full/
      - Tokens de generar context.yaml

      Esto es ineficiente y puede superar límites de contexto.

    decision: |
      Main-Agent tiene restricción explícita en agents/main-agent.yaml:
      - NO proponer ejecutar @memsys3/prompts/compile-context.md
      - Solo sugerir endSession al finalizar sesión
      - El user decide cuándo compilar (en nueva instancia limpia)

      compile-context.md debe ejecutarse en una NUEVA INSTANCIA sin tokens acumulados.

    alternatives:
      - nom: "Main-Agent ejecuta compile-context"
        pros:
          - Automático
          - Conveniente
        contras:
          - Acumula demasiados tokens
          - Ineficiente
          - Puede superar límites
        por_que_descartada: "Consume demasiados tokens innecesariamente"

      - nom: "Compilación automática en cada endSession"
        pros:
          - Context siempre actualizado
        contras:
          - Cada endSession sería muy pesado
          - No siempre es necesario recompilar
        por_que_descartada: "Overhead innecesario"

    consequencies:
      positives:
        - "Eficiencia de tokens optimizada"
        - "Main-Agent se enfoca en desarrollo"
        - "Context Agent trabayaconinstancia limpia"
        - "User controla cuándo compilar"
      negatives:
        - "Requiere paso manual extra de compilación"
        - "Context puede quedar desactualizado entre compilaciones"
      impacto: "Cómo se gestiona el workflow de compilación de contexto"

  - id: "001"
    titulo: "Criterio inteligente del Context Agent vs límites arbitrarios"
    data: "2025-10-28"
    estado: aceptado
    area: arquitectura

    context: |
      Los sistemas anteriores usaban límites rígidos (máx 7 ADRs, máx 15 líneas por sesión)
      que no se adaptaban a la realidad del proyecto. Proyectos pequeños perdían contexto,
      proyectos grandes no podían expresarse adecuadamente.

    decision: |
      El Context Agent usa criterio inteligente basándose en la pregunta:
      "¿Qué debe saber CUALQUIER agent descontextualizado para trabajar aquí?"

      Límite ÚNICO: máximo 2000 líneas en context.yaml final.
      NO hay límites arbitrarios para ADRs, sessions, gotchas, etc.

    alternatives:
      - nom: "Mantener límites arbitrarios"
        pros:
          - Predecible
          - Fácil de implementar
        contras:
          - No se adapta a realidad del proyecto
          - Pierde información crítica o incluye información irrelevante
        por_que_descartada: "Demasiado rígido, no escala con complejidad del proyecto"

      - nom: "Sin límite (contexto ilimitado)"
        pros:
          - Todo el contexto disponible
        contras:
          - Consume demasiados tokens
          - Supera límites de Read tool (2000 líneas)
        por_que_descartada: "No sostenible, problemas técnicos con Read"

    consequencies:
      positives:
        - "Contexto adaptativo según necesidades del proyecto"
        - "CA decideconvisión panorámica completa"
        - "Proyectos pequeños mantienen todo, proyectos grandes filtran inteligentemente"
        - "Más flexible y escalable"
      negatives:
        - "Menos predecible (depende criterio CA)"
        - "Puede variar entre compilaciones"
      impacto: "Cómo se compila todo el contexto del sistema"

  - id: "002"
    titulo: "Rotación automática de sessions/ADRs (>1800 líneas)"
    data: "2025-10-28"
    estado: aceptado
    area: escalabilidad

    context: |
      Read tool tiene límite de 2000 líneas. Si sessions.yaml o adr.yaml crecen
      demasiado, los agents no pueden leerlos.

    decision: |
      Cuando sessions.yaml o adr.yaml superen 1800 líneas:
      - endSession.md detecta automáticamente
      - Hace rotación segura: copia → verifica → crea nuevo
      - sessions.yaml → sessions_N.yaml
      - adr.yaml → adr_N.yaml

      Context Agent lee TODOS los archivos rotados hasta detectar >150K tokens.

    alternatives:
      - nom: "Límite fijo de sessions/ADRs"
        pros:
          - Simple
        contras:
          - Pierde histórico
        por_que_descartada: "No queremos perder datos nunca"

      - nom: "Base de datos"
        pros:
          - Sin límites
        contras:
          - Complejidad adicional
          - Dependencia externa
        por_que_descartada: "YAML files son suficientes y simples"

    consequencies:
      positives:
        - "Sistema escala infinitamente"
        - "No se pierden datos nunca"
        - "Automático, sin intervención manual"
        - "Preserva histórico completo"
      negatives:
        - "Múltiples archivos (sessions_1, sessions_2, etc.)"
        - "CA debe leer múltiples archivos"
      impacto: "Cómo se gestiona el crecimiento de datos históricos"

  - id: "003"
    titulo: "Plan de Contingenciaconarchivado inteligente (>150K tokens)"
    data: "2025-10-28"
    estado: aceptado
    area: escalabilidad

    context: |
      Inclusoconrotación, proyectos muy grandes pueden acumular demasiados datos.
      Si full/ (con todos los archivos rotados) supera 150K tokens, el CA no puede
      procesarlo eficientemente.

    decision: |
      Cuando todal de full/ supera 150K tokens:
      1. CA identifica ADRs/sessions irrelevantes con criterio inteligente
      2. Los mueve a memory/history/ (que NO se lee)
      3. Reduce a ~120K tokens
      4. Continúa compilación normal

      Datos en history/ están preservados, recuperables si es necesario.

    alternatives:
      - nom: "Borrar datos antiguos"
        pros:
          - Limpieza automática
        contras:
          - Pierde información irreversiblemente
        por_que_descartada: "NEVER delete data"

      - nom: "Comprimir archivos"
        pros:
          - Reduce tamaño
        contras:
          - CA no puede leer comprimido
        por_que_descartada: "No resuelve problema de tokens"

    consequencies:
      positives:
        - "Ahorro real de tokens (history/ NO se lee)"
        - "Datos preservados, no perdidos"
        - "Sistema escala ilimitadamente"
        - "Reversible (puedes recuperar de history/)"
      negatives:
        - "Datos archivados no visibles para CA"
        - "Depende criterio CA para archivar"
      impacto: "Cómo se gestionan proyectosconmucho histórico"

  - id: "004"
    titulo: "YAML para todo (incluyendo sessions)"
    data: "2025-10-28"
    estado: aceptado
    area: format

    context: |
      Sessions originalmentee eran .md (Markdown). Templates y ADRs ya eran YAML.
      Inconsistencia de formatos dificultaba parsing y ahorro de tokens.

    decision: |
      Todo el sistema usa YAML:
      - sessions.yaml (antes sessions.md)
      - adr.yaml
      - project-status.yaml
      - context.yaml
      - Todos los templates .yaml

    alternatives:
      - nom: "Markdown para sessions"
        pros:
          - Más legible para humans
        contras:
          - Inconsistentconresto
          - Más tokens (~30% más)
          - Difícil parsear para LLMs
        por_que_descartada: "Queríamos consistència y eficiencia"

      - nom: "JSON"
        pros:
          - Estándar web
        contras:
          - Menos legible
          - No soporta multiline strings fácilmente
        por_que_descartada: "YAML mejor para documentación"

    consequencies:
      positives:
        - "Consistencia todal del sistema"
        - "~30% ahorro tokens vs Markdown"
        - "Mejor para LLMs (estructura clara)"
        - "Fácil parsearconjs-yaml"
      negatives:
        - "Menos familiar para algunos devs"
        - "Requiere indentació estricta"
      impacto: "Formato de toda la documentació del sistema"

  - id: "005"
    titulo: "deploy.md como prompt (no script shell)"
    data: "2025-10-28"
    estado: aceptado
    area: usabilidad

    context: |
      Necesitábamos manera de desplegar memsys3 en nuevos proyectos.
      Opciones: script shell automático vs prompt para Main-Agent.

    decision: |
      Crear prompts/deploy.md que el Main-Agent ejecuta.
      El agent hace briefingconuser para personalizar el deployment:
      - Pregunta sobre proyecto, stack, comportamiento
      - Copia templates
      - Crea archivos específicos basándose en respuestas

      Más flexible que script automático.

    alternatives:
      - nom: "Script shell (setup.sh)"
        pros:
          - Automático
          - Rápido
        contras:
          - Menos flexible
          - No puede hacer briefingconuser
          - Requeriría CLI interactivo complex
        por_que_descartada: "Promptconagent es más inteligente y flexible"

      - nom: "Manual (README instructions)"
        pros:
          - Simple
        contras:
          - Propensos a errores humanos
          - Lento
        por_que_descartada: "Queríamos automatización"

    consequencies:
      positives:
        - "Deployment guiado e inteligente"
        - "Personalización según necesidades"
        - "Agent puede adaptarse a respuestas"
        - "Consistentconfilosofía de prompts"
      negatives:
        - "Requiere AI agent paraejecutar"
        - "No funciona sense agent"
      impacto: "Com los usuarios despliegan memsys3 en los sus proyectos"

  - id: "009"
    titulo: "Templates como documentació activa permanent + gotchas en sessions"
    data: "2025-10-31"
    estado: aceptado
    area: arquitectura

    context: |
      Durante la validación del deployment surgió confusión sobre tres aspectos:

      1. **Templates dentro de templates**: memsys3_templates/ es una carpeta-template completa,
         pero dentro tiene memory/templates/. Esto genera la pregunta: ¿qué es template de qué?

      2. **Uso de templates/**: Inicialmente se pensó en borrar memory/templates/ después
         del deployment, pero al revisar el contenido se descubrió que contiene:
         - Estructura exacta de ADRs, sessions, project-status
         - Instrucciones de uso (orden cronológico, límites, etc.)
         - Ejemplos de buena vs mala documentación
         - Especificaciones que endSession.md no detalla

      3. **Ubicación de gotchas**: project-status-template.yaml incluye sección gotchas_i_issues,
         pero los gotchas surgen DURANTE sesiones de trabajo, no son características estáticas
         del proyecto.

    decision: |
      **1. Concepto de memsys3_templates/ (ms3t):**
      - ms3t/ = Estructura EXACTA del producto final
      - Todos los archivos se copian durante deployment (incluido memory/templates/)
      - memory/templates/ NO se borra después del deployment

      **2. memory/templates/ = Guías permanentes:**
      - Main-Agent consulta templates/ durante endSession.md
      - "¿Cómo estructuro esta sesión?" → sessions-template.yaml
      - "¿Qué campos tiene un ADR?" → adr-template.yaml
      - "¿Qué puedo actualizar en project-status?" → project-status-template.yaml
      - Templates son documentación ACTIVA, no solo guías de deployment

      **3. Gotchas documentados en sessions.yaml:**
      - Main-Agent documenta gotchas en cada sesión donde aparecen
      - Estructura en sessions.yaml:
        ```yaml
        sessions:
          - id: "2025-10-31"
            gotchas:
              - tipus: "warning|gotcha|issue"
                problema: "[DESCRIPCIÓ]"
                solucio: "[COM RESOLDRE]"
                criticidad: "alta|media|baja"
        ```
      - Context-Agent extrae gotchas de TODAS las sesiones
      - CA usa criterio inteligente para seleccionar top 5 más críticos
      - Criterios: criticidad + recencia + impacto
      - project-status.yaml NO contiene gotchas (solo info general del proyecto)

      **4. Templatesconcomentarios explicativos:**
      - Camposcon[PLACEHOLDER] y comentarios inline
      - Ejemplos de buenas prácticas
      - deploy.md usa templates como guía para hacer briefing

      **5. Workflow de deployment actualizado:**
      ```bash
      # Usuario dice:
      "Clona https://github.com/iv0nis/memsys3 como memsys3_temp
       y ejecuta memsys3_temp/memsys3/prompts/deploy.md"

      # Flujo:
      1. git clone https://github.com/iv0nis/memsys3 memsys3_temp
      2. cp -r memsys3_temp/memsys3/* ./memsys3/
      3. Briefing usando templates/ como guía
      4. Rellenar campos vacíos en project-status.yaml, main-agent.yaml
      5. rm -rf memsys3_temp/

      # Resultado: memsys3/conmemory/templates/ incluido (permanente)
      ```

    alternatives:
      - nom: "Borrar templates/ després del deployment"
        pros:
          - Menos archivos en el proyecto desplegado (~15KB menos)
          - Más limpio
        contras:
          - Main-Agent pierde referencia de cómo documentar
          - endSession.md no tiene guía de estructura
          - Ejemplos de buenas prácticas se pierden
        por_que_descartada: "Templates son críticos para Main-Agent durante todo el proyecto"

      - nom: "Gotchas en project-status.yaml"
        pros:
          - Centralizado en un solo lugar
          - Fácil de encontrar
        contras:
          - Descontextualizados (no se sabe cuándo aparecieron)
          - project-status más inflado
          - No tiene sentido conceptual (gotchas surgen durante sesiones)
        por_que_descartada: "Gotchas son eventos de sesiones, no características estáticas"

      - nom: "Crear archivo gotchas.yaml separat"
        pros:
          - Dedicado solo a gotchas
        contras:
          - Un archivo más
          - Descontextualizados igualmente
          - CA debería leer un archivo extra
        por_que_descartada: "Sessions ya documentan contexto temporal de los gotchas"

    consequencies:
      positives:
        - "Deployment más simple: copiar todo, no borrar templates/"
        - "Main-Agent siempre tiene referencia de cómo documentar correctamente"
        - "Gotchas contextualizados (cuándo aparecieron, en qué sesión)"
        - "CA tiene flexibilidad para priorizar gotchas según criterio"
        - "project-status.yaml más limpio (solo info general)"
        - "Templates enriquecidosconcomentarios guían briefing de deployment"
        - "~15KB extra en proyecto (4 templates, aceptable)"
      negatives:
        - "memory/templates/ se mantiene pero no se borra (puede parecer residual)"
        - "Gotchas dispersos entre sesiones (hay que leer todas para compilar)"
        - "Templates/ como nombre puede generar confusión (son guías, no templates)"
      impacto: "Cómo se despliega memsys3, cómo Main-Agent documenta sesiones, dónde se guardan gotchas"

    notes: |
      Esta ADR resuelve confusiones críticas descubiertas durante validación de deployment.

      Consideración futura: Quizás renombrar memory/templates/ a memory/guides/ para más
      claridad conceptual, pero se mantiene templates/ para no romper nada ahora.

  - id: "010"
    titulo: "Consulta .gitignore durante deployment de memsys3"
    data: "2025-11-12"
    estado: aceptado
    area: deployment

    context: |
      Durante el deployment de memsys3 en tallersColomer, se identificó que memsys3/
      no estaba excluido de git, lo que significa que todo el contexto local (sessions,
      ADRs, gotchas) se subiría al repositorio.

      El problema es que memsys3/ contiene:
      - Sesiones de trabajo con Claude (información del flujo de trabajo)
      - Decisiones arquitectónicas internas del desarrollo
      - Gotchas y aprendizajes específicos del proceso
      - Contexto que es útil localmente pero NO debe ser público

      Actualmente deploy.md NO pregunta al usuario si quiere excluir memsys3/ de git,
      lo cual puede llevar a subir información que debería ser privada.

    decision: |
      Agregar PASO 8 en deploy.md que pregunte al usuario si quiere excluir memsys3/
      de GitHub ANTES de finalizar el deployment.

      El paso incluye:
      1. Explicación de por qué es recomendable excluir memsys3/
      2. Dos opciones claras:
         - Opción A: Excluir (RECOMENDADO) - para desarrollo individual
         - Opción B: Incluir - para equipos que quieran compartir contexto
      3. WARNING sobre limitación Claude Code: @ mentions NO funcionan con archivos ignorados
      4. Workaround claro: usar instrucciones directas ("Ejecuta memsys3/prompts/newSession.md")
      5. Instrucciones para modificar .gitignore si el usuario elige Opción A
      6. Verificación con git status

      El paso es obligatorio (siempre se pregunta), pero la decisión es del usuario.

      IMPORTANTE: Si el usuario elige Opción A (excluir), debe saber que NO podrá usar
      @ mentions para los prompts, pero el sistema funcionará igual usando instrucciones
      directas a Claude.

    alternatives:
      - nom: "Excluir automáticamente sin preguntar"
        pros:
          - Más simple, sin interacción
          - Seguro por defecto
        contras:
          - Asume que nadie quiere compartir el contexto
          - Equipos no podrían colaborar con memsys3 compartido
          - Usuario puede no saber que se excluyó
        por_que_descartada: "No todos los casos de uso son iguales, algunos equipos pueden querer compartir contexto"

      - nom: "Incluir por defecto sin preguntar"
        pros:
          - Sin fricción en deployment
        contras:
          - Sube información sensible por defecto
          - Contexto local innecesario en repos públicos
          - Infla el repositorio con datos cambiantes
        por_que_descartada: "Riesgo de privacidad alto, información sensible puede filtrarse"

      - nom: "Documentar en deploy.md pero no automatizar"
        pros:
          - Usuario decide manualmente después
        contras:
          - Fácil de olvidar
          - Se descubre tarde (ya se subió a git)
          - Requiere revertir commits
        por_que_descartada: "Deployment debe ser completo, no dejar tareas pendientes"

    consequencies:
      positives:
        - "Usuario es consciente de la decisión de privacidad"
        - "Flexibilidad: equipos pueden elegir compartir contexto si quieren"
        - "Deployment completo y correcto desde el inicio"
        - "No hay sorpresas después (ya se subió a git accidentalmente)"
        - "Recomendación clara (Opción A recomendada)"
        - "Warning explícito sobre limitación @ mentions con workaround claro"
        - "Usuario sabe desde el inicio cómo invocar prompts si elige Opción A"
      negatives:
        - "Un paso más en el deployment (fricción mínima)"
        - "Usuario debe tomar una decisión (aunque hay recomendación)"
        - "Si elige Opción A: @ mentions no funcionan (limitación Claude Code)"
        - "Requiere usar instrucciones directas en lugar de @ mentions (cambio UX)"
      impacto: "Privacidad del contexto, configuración .gitignore, UX de invocación de prompts"

    notes: |
      Esta ADR surgió de experiencia real durante deployment en tallersColomer.
      La consulta se agregó como Paso 8 en deploy.md (entre Paso 7 y antiguo Paso 8).

      Consideración: La mayoría de proyectos deberían excluir memsys3/, pero hay
      casos de uso legítimos para incluirlo (equipos pequeños, repos privados de empresa).

      UPDATE 2025-11-13: Se descubrió que @ mentions NO funcionan con archivos en .gitignore
      (limitación de seguridad de Claude Code). Se agregó warning explícito y workaround claro
      en PASO 8. El sistema funciona perfectamente, solo cambia la forma de invocar prompts:
      - ❌ @memsys3/prompts/newSession.md (no funciona si está ignorado)
      - ✅ "Ejecuta memsys3/prompts/newSession.md" (funciona siempre)

  - id: "011"
    titulo: "Separación de prompts agnósticos (distribuibles) vs específicos (proyecto memsys3)"
    data: "2025-11-17"
    estado: aceptado
    area: arquitectura

    context: |
      Durante el desarrollo de memsys3 surgió la necesidad de crear prompts que solo tienen
      sentido en el contexto del desarrollo del propio memsys3, NO en proyectos que usen memsys3.

      Ejemplos detectados:
      - actualizar_cat.md: Sincroniza memsys3_templates/ español → catalán (branch catalan GitHub)
      - comprobar_alineamiento.md: Verifica sincronización dog-fooding ↔ templates

      El problema: Inicialmente estos archivos se crearon en memsys3/prompts/ y memsys3_templates/prompts/,
      lo que significa que se DISTRIBUIRÍAN a otros proyectos durante el deployment.

      Esto contaminaría los deployments con herramientas internas específicas del desarrollo de memsys3
      que no tienen sentido fuera de este repositorio.

      Necesidad: Regla clara para determinar qué es agnóstico (distribuible) vs específico (solo memsys3).

    decision: |
      **Regla de Oro para decidir ubicación de archivos:**

      Pregunta: "¿Tiene sentido este archivo en CUALQUIER proyecto que use memsys3?"
      - SI SÍ → Agnóstico: va en memsys3_templates/ (se distribuye)
      - SI NO → Específico: va en directorios raíz como /prompts/ (NO se distribuye)

      **Ubicaciones:**

      1. AGNÓSTICOS (distribuibles) → memsys3_templates/:
         - prompts/newSession.md ✅
         - prompts/endSession.md ✅
         - prompts/compile-context.md ✅
         - prompts/deploy.md ✅
         - prompts/actualizar.md ✅
         - prompts/mind.md ✅
         - prompts/backlog.md ✅
         - prompts/github.md ✅
         - agents/*.yaml ✅
         - memory/templates/*.yaml ✅
         - viz/* ✅

      2. ESPECÍFICOS (solo memsys3) → /prompts/ en raíz:
         - prompts/actualizar_cat.md ❌ (solo memsys3 tiene versión catalana)
         - prompts/comprobar_alineamiento.md ❌ (solo memsys3 tiene dog-fooding)
         - Futuros prompts de desarrollo interno ❌

      **Implementación sin enforcement rígido:**

      La ADR NO especifica archivos concretos a verificar (brindis al sol), sino que:
      1. Documenta la REGLA DE ORO en README.md sección Dog-fooding
      2. Confía en que el Context Agent incluirá esta ADR en context.yaml
      3. Los futuros agents trabajando en memsys3 verán la regla en su contexto
      4. La práctica "emerge" del contexto compilado (meta-memsys3)

      **Práctica recomendada (documentada en README.md):**
      "Al finalizar sesiones donde modificaste archivos agnósticos, ejecutar
      @prompts/comprobar_alineamiento.md ANTES de endSession para verificar
      sincronización dog-fooding ↔ templates."

      Esta práctica NO se incluye en endSession.md distribuible (contaminaría deployments),
      sino que emerge del contexto del proyecto memsys3.

    alternatives:
      - nom: "Verificación automática con script pre-commit"
        pros:
          - Enforcement rígido
          - Imposible cometer error
        contras:
          - Complejidad adicional (git hooks)
          - Fricción en desarrollo
          - No flexible
        por_que_descartada: "Preferimos confiar en el sistema memsys3 (contexto compilado) para crear la práctica naturalmente"

      - nom: "Modificar endSession.md con recordatorio"
        pros:
          - Recordatorio visible siempre
        contras:
          - Contamina endSession.md distribuible
          - Recordatorio aparecería en TODOS los proyectos
          - Va contra filosofía agnóstico/específico
        por_que_descartada: "endSession.md es agnóstico, no debe tener lógica específica de memsys3"

      - nom: "Todos los prompts en memsys3_templates/"
        pros:
          - Simple, todo en un lugar
        contras:
          - Distribuye herramientas internas a otros proyectos
          - Contamina deployments
          - Confusión en proyectos destino
        por_que_descartada: "Rompe la filosofía de distribución limpia"

    consequencies:
      positives:
        - "Deployments limpios: solo archivos agnósticos se distribuyen"
        - "Claridad sobre qué es producto (templates) vs desarrollo interno"
        - "Regla simple y memorable para tomar decisiones"
        - "Práctica emerge del contexto (dog-fooding real de memsys3)"
        - "No requiere enforcement rígido (confía en el sistema)"
        - "Flexible: nuevos archivos se clasifican fácilmente"
      negatives:
        - "Requiere disciplina al crear nuevos archivos (pensar dónde ubicarlos)"
        - "No hay verificación automática (confianza en contexto)"
        - "Prompts específicos en /prompts/ pueden olvidarse"
      impacto: "Qué archivos se distribuyen durante deployment, claridad de separación producto vs desarrollo"

    notes: |
      Esta ADR usa memsys3 para desarrollar memsys3 (meta):
      - La regla se documenta en README.md
      - Context Agent la incluye en context.yaml compilado
      - Futuros agents la ven en su contexto al cargar newSession.md
      - La práctica emerge naturalmente sin modificar archivos distribuibles

      Dog-fooding real del concepto: el sistema se documenta a sí mismo.
